package main

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"

	"go/format"
)

func defineAst(outputDir, baseName string, types []string) {
	funcMap := template.FuncMap{
		"ToLower": strings.ToLower,
	}

	tmpl, err := template.New("ast").Funcs(funcMap).Parse(`
// Code generated by generate-ast. DO NOT EDIT.
package ast

import "github.com/michael-go/lox/golox/internal/token"

type {{.BaseName -}}[R any] interface {
	Accept(visitor Visitor[R]) R
}

{{range $name, $fields := .Classes}}
type {{$name}}[R any] struct {
	{{- range $field := $fields}}
	{{$field -}}
	{{end}}
}
{{end}}

type Visitor[R any] interface {
	{{range $name, $fields := .Classes -}}
	Visit{{$name}}{{$.BaseName}}({{$.BaseName | ToLower}} {{$name}}[R]) R
	{{end}}
}

{{range $name, $fields := .Classes}}
func ({{$.BaseName | ToLower}} {{$name}}[R]) Accept(visitor Visitor[R]) R {
	return visitor.Visit{{$name}}{{$.BaseName}}({{$.BaseName | ToLower}})
}
{{end}}


`)
	if err != nil {
		panic(err)
	}

	classes := map[string][]string{}

	for _, t := range types {
		s := strings.Split(t, ":")
		name := strings.TrimSpace(s[0])
		fields := strings.Split(s[1], ",")
		for i, f := range fields {
			fields[i] = strings.TrimSpace(f)
		}

		classes[name] = fields
	}

	var output bytes.Buffer

	err = tmpl.Execute(&output, map[string]any{
		"BaseName": baseName,
		"Classes":  classes,
	})
	if err != nil {
		panic(err)
	}

	formatted, formatErr := format.Source(output.Bytes())
	if formatErr == nil {
		output = *bytes.NewBuffer(formatted)
	}

	path := fmt.Sprintf("%s/%s.go", outputDir, strings.ToLower(baseName))
	file, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	_, err = file.Write(output.Bytes())
	if err != nil {
		panic(err)
	}

	if formatErr != nil {
		panic(fmt.Errorf("error formatting: %w", formatErr))
	}

}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Usage: generate-ast <output directory>")
		os.Exit(1)
	}
	outputDir := os.Args[1]

	defineAst(outputDir, "Expr", []string{
		"Binary   : Left Expr[R], Operator token.Token, Right Expr[R]",
		"Grouping : Expression Expr[R]",
		"Literal  : Value any",
		"Unary    : Operator token.Token, Right Expr[R]",
	})
}
